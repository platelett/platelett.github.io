<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"platelet.top","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="此页面的 Telegram 频道。 科普一些常见算法的常数优化，以及一些底层优化的基础知识。  ST 表 (Sparse Table) 2023-11-02  ST 表的数组，哪维放前面更快？ ⌊log⁡2(r−l+1)⌋\lfloor\log_2(r-l+1)\rfloor⌊log2​(r−l+1)⌋ 怎么算最快？  对于一个序列 AAA，定义 tk,i&#x3D;min⁡Ai−2k+1∼it_{k,i}">
<meta property="og:type" content="website">
<meta property="og:title" content="卡常 Tips">
<meta property="og:url" content="https://platelet.top/hpc/index.html">
<meta property="og:site_name" content="platelet&#39;s blog">
<meta property="og:description" content="此页面的 Telegram 频道。 科普一些常见算法的常数优化，以及一些底层优化的基础知识。  ST 表 (Sparse Table) 2023-11-02  ST 表的数组，哪维放前面更快？ ⌊log⁡2(r−l+1)⌋\lfloor\log_2(r-l+1)\rfloor⌊log2​(r−l+1)⌋ 怎么算最快？  对于一个序列 AAA，定义 tk,i&#x3D;min⁡Ai−2k+1∼it_{k,i}">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-11-02T11:50:46.000Z">
<meta property="article:modified_time" content="2023-11-10T08:17:20.487Z">
<meta property="article:tag" content="platelet">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://platelet.top/hpc/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":false,"lang":"zh-CN","comments":true,"permalink":"https://platelet.top/hpc/index.html","path":"hpc/index.html","title":"卡常 Tips"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>卡常 Tips | platelet's blog
</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">platelet's blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">精于心，简于形</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-关于我"><a href="/about-me/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li><li class="menu-item menu-item-算法模板"><a href="/template/" rel="section"><i class="fa fa-code fa-fw"></i>算法模板</a></li><li class="menu-item menu-item-题解区"><a href="/solutions/" rel="section"><i class="fa fa-book fa-fw"></i>题解区</a></li><li class="menu-item menu-item-卡常-tips"><a href="/hpc/" rel="section"><i class="fa fa-book fa-fw"></i>卡常 Tips</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#st-%E8%A1%A8-sparse-table"><span class="nav-number">1.</span> <span class="nav-text"> ST 表 (Sparse Table)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#set-%E5%92%8C-map"><span class="nav-number">2.</span> <span class="nav-text"> set 和 map</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#insertit-x-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text"> insert(it, x) 的用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eraseit-%E7%9A%84%E5%A6%99%E7%94%A8"><span class="nav-number">2.2.</span> <span class="nav-text"> erase(it) 的妙用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#it-it-%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">2.3.</span> <span class="nav-text"> it++, it-- 的复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E4%BE%BF%E5%88%A9%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.</span> <span class="nav-text"> 一些便利的函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9D%E6%8E%A2%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80"><span class="nav-number">3.</span> <span class="nav-text"> 初探循环展开</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5"><span class="nav-number">3.1.</span> <span class="nav-text"> 问题引入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">3.2.</span> <span class="nav-text"> 循环展开的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E6%9E%81%E7%AB%AF%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">3.2.1.</span> <span class="nav-text"> 一个极端的例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E5%B1%95"><span class="nav-number">3.3.</span> <span class="nav-text"> 拓展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E5%8A%A0"><span class="nav-number">3.3.1.</span> <span class="nav-text"> 整体加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">3.3.2.</span> <span class="nav-text"> 前缀和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E5%9E%8B%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95"><span class="nav-number">3.3.3.</span> <span class="nav-text"> 小型矩阵乘法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-pragma-%E8%87%AA%E5%8A%A8%E5%B1%95%E5%BC%80"><span class="nav-number">3.3.4.</span> <span class="nav-text"> 使用 pragma 自动展开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-c-template-%E8%87%AA%E5%8A%A8%E5%B1%95%E5%BC%80"><span class="nav-number">3.3.5.</span> <span class="nav-text"> 使用 C++ template 自动展开</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%90%88%E5%B9%B6"><span class="nav-number">4.</span> <span class="nav-text"> 循环的合并</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E5%BE%AA%E7%8E%AF%E5%9C%A8-oi-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">4.1.</span> <span class="nav-text"> 合并循环在 OI 中的应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%88%86%E8%A3%82"><span class="nav-number">5.</span> <span class="nav-text"> 循环的分裂</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E7%AE%97%E6%9C%AF%E4%BC%98%E5%8C%96-i"><span class="nav-number">6.</span> <span class="nav-text"> 模算术优化 I</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner page posts-expand">


    
    
    
    <div class="post-block" lang="zh-CN"><header class="post-header">

<h1 class="post-title" itemprop="name headline">卡常 Tips
</h1>

<div class="post-meta-container">
</div>

</header>

      
      
      <div class="post-body">
          <p>此页面的 <a target="_blank" rel="noopener" href="https://t.me/platelett">Telegram 频道</a>。</p>
<p>科普一些常见算法的常数优化，以及一些底层优化的基础知识。</p>
<h1 id="st-表-sparse-table"><a class="markdownIt-Anchor" href="#st-表-sparse-table"></a> ST 表 (Sparse Table)</h1>
<p><em>2023-11-02</em></p>
<ul>
<li>ST 表的数组，哪维放前面更快？</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor\log_2(r-l+1)\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">⌋</span></span></span></span> 怎么算最快？</li>
</ul>
<p>对于一个序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>，定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub><mo>=</mo><mi>min</mi><mo>⁡</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>−</mo><msup><mn>2</mn><mi>k</mi></msup><mo>+</mo><mn>1</mn><mo>∼</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{k,i}=\min A_{i-2^k+1\sim i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9442809999999999em;vertical-align:-0.26095099999999993em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.49738em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mrel mtight">∼</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26095099999999993em;"><span></span></span></span></span></span></span></span></span></span>，注意区间是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><msup><mn>2</mn><mi>k</mi></msup><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i-2^k+1,i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 而非 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i,i+2^k-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，这样定义的好处是代码短一点，通过下面的式子预处理：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>t</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi></mrow></msub><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>i</mi><mo>−</mo><msup><mn>2</mn><mi>k</mi></msup></mrow></msub><mo separator="true">,</mo><msub><mi>t</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t_{k+1,i}=\min(t_{k,i-2^k},t_{k,i})
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.088728em;vertical-align:-0.3387279999999999em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.4973800000000006em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3387279999999999em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>这里有两个问题：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> 数组应该把哪一维放前面？</li>
<li>预处理的两个 <code>for</code> 应该把哪个放前面？</li>
</ul>
<div class="note success"><p>最优的组合</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; log_n; k++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> &lt;&lt; k; i &lt;= n; i++)</span><br><span class="line">        t[k + <span class="number">1</span>][i] = <span class="built_in">min</span>(t[k][i - (<span class="number">1</span> &lt;&lt; k)], t[k][i]);</span><br></pre></td></tr></table></figure></div>
<details class="note info"><summary><p>解释 (访问连续性, 指令级并行)</p>
</summary>
<p>这里有两个知识，<em>访问连续性</em> 和 <em>指令级并行</em>。</p>
<div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><a href="#1-1">访问连续性</a></li><li class="tab"><a href="#1-2">指令级并行</a></li></ul><div class="tab-content"><div class="tab-pane active" id="1-1"><p>当数组下标连续递增或递减时，访问的平均时间会很小，远小于随机访问。注意，在多个数组上连续访问也是有效的，数组的数量不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>256</mn></mrow><annotation encoding="application/x-tex">256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span></span></span></span> 应该都是可以接受的（有个例外是 4K Aliasing，它不重要）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum += a[i] + b[i] + c[i];</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="1-2"><p>当简单循环中的每条语句的 <strong>互相独立</strong> 时，可以获得一种加速叫 <em>指令级并行</em>，多条机器指令可以同时执行。</p>
<p>互相独立是指执行顺序不重要，并且要修改的变量没有一样的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序很重要</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] += a[i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 都要修改 sum</span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum += a[i];</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 互相独立</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] += val;</span><br></pre></td></tr></table></figure>
<p><em>指令级并行</em> 其实无处不在，只是循环中的语句互相独立的时候，更容易同时执行。</p></div></div></div>
<p>不难看出，最优组合同时具备 <em>访问连续性</em> 和 <em>指令级并行</em>。值得一提的是，下面这种组合也具备 <em>访问连续性</em>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为避免下标为负数，加上一个常量 OFFSET</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; log_n; k++)</span><br><span class="line">        t[k + <span class="number">1</span>][i + OFFSET] = <span class="built_in">min</span>(t[k][i - (<span class="number">1</span> &lt;&lt; k) + OFFSET], t[k][i + OFFSET]);</span><br></pre></td></tr></table></figure>
<details class="note info"><summary><p>想一想为什么？</p>
</summary>
<p>对于每一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>，访问的值有</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t[<span class="number">0</span>][i] t[<span class="number">1</span>][i] ... t[log_n][i]</span><br><span class="line">t[<span class="number">0</span>][i<span class="number">-1</span>] t[<span class="number">1</span>][i<span class="number">-2</span>] ... t[log_n][i-(<span class="number">1</span>&lt;&lt;log_n)]</span><br></pre></td></tr></table></figure>
<p>每一个都是随着 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 连续访问的，常数个指针同时连续移动也是一种 <em>访问连续性</em>。</p>
</details>
</details>
<p>询问的时候有两个问题：</p>
<ul>
<li>数组哪一维放前面会比较快。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor\log_2(r-l+1)\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">⌋</span></span></span></span> 怎么算最快。</li>
</ul>
<div class="note success"><p>仍然是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span></span></span></span> 的一维放前面。</p>
</div>
<details class="note info"><summary><p>解释 (访问分布, 缓存)</p>
</summary>
<p>不管哪一维放前面，数组都是随机访问的。</p>
<p>但是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\log(r-l+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> <strong>通常不是均匀分布的</strong>，不管是随机数据还是大部分构造数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\log(r-l+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 倾向于集中于某个值，<em>缓存</em> 让访问得以加速。</p>
<details class="note info"><summary><p>缓存</p>
</summary>
<p>缓存是一个缩小版的内存，比起内存有更高的访问速度，但可用空间也更小，访问频率最高的数据会自动留在缓存中。</p>
<p>因此当某些数据的访问频率较高时，缓存就会起作用，让平均访问时间变短。</p>
</details>
<p>当然，如果特意让 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\log_2(r-l+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,\log_2 n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> 均匀生成，哪一维放前面速度就一样了。</p>
</details>
<p>最后是计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor\log_2(r-l+1)\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">⌋</span></span></span></span> 的问题，最常见的方法是预处理一个 <code>log_2</code> 数组，更好的方法是使用 <code>std::__lg(r - l + 1)</code> 或 <code>31 - __builtin_clz(r - l + 1)</code>。</p>
<div class="note success"><p>最快的方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">31</span> ^ __builtin_clz(r - l + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,10^6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 均匀随机时，速度比较如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>31 ^ __builtin_clz(x)</code></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.00</mn></mrow><annotation encoding="application/x-tex">1.00</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center"><code>__lg(x)</code></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.40</mn></mrow><annotation encoding="application/x-tex">1.40</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">4</span><span class="mord">0</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center"><code>log_2[x]</code></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>∼</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">8\sim9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span></td>
</tr>
</tbody>
</table>
</div>
<details class="note info"><summary><p>解释</p>
</summary>
<ul>
<li><code>log_2[x]</code> 需要访问较大数组，所以速度慢。</li>
<li><code>__lg(x)</code> 等价于 <code>31 - __builtin_clz(x)</code>，而 <code>__builtin_clz(x)</code> 会编译为 <code>31 ^ __builtin_ia32_bsrsi(x)</code>。</li>
<li><code>31 ^ __builtin_clz(x)</code> 编译后两个异或会抵消，结果为 <code>__builtin_ia32_bsrsi(x)</code>，比前一种方法少了一次减法和异或。</li>
</ul>

</details>
<h1 id="set-和-map"><a class="markdownIt-Anchor" href="#set-和-map"></a> set 和 map</h1>
<p><em>2023-11-03</em></p>
<p><code>std::set</code> 最常用的函数有：</p>
<ul>
<li>用于修改的 <code>insert(x)</code>, <code>erase(x)</code>, <code>erase(it)</code>（指定迭代器）。</li>
<li>用于查询的 <code>find(x)</code>, <code>lower_bound(x)</code>, <code>upper_bound(x)</code>。</li>
<li>迭代器 <code>it++, it--</code>。</li>
</ul>
<p>想减少 <code>set</code> 的时间开销，一般有两种方法：</p>
<div class="note success"><p>利用 <code>insert(x)</code> 和 <code>erase(it)</code> 的返回值，减少函数调用。</p>
</div>
<div class="tabs" id="2"><ul class="nav-tabs"><li class="tab active"><a href="#2-1">insert(x)</a></li><li class="tab"><a href="#2-2">erase(it)</a></li></ul><div class="tab-content"><div class="tab-pane active" id="2-1"><details class="note info"><summary><p>insert(x) 的返回值</p>
</summary>
<p>insert 函数的返回值类型为 <code>pair&lt;iterator, bool&gt;</code>，bool 代表元素是否插入成功，iterator 则是一个迭代器，指向所插入元素，或者指向原本就在容器中的元素。</p>
</details>
<blockquote>
<p>实现一个函数，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 不在 <code>set</code> 中就插入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，否则删除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foobar</span><span class="params">(set&lt;<span class="type">int</span>&gt;&amp; s, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [it, t] = s.<span class="built_in">insert</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (!t) s.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="2-2"><details class="note info"><summary><p>erase(it) 的返回值</p>
</summary>
<p>erase(it) 函数的返回值为迭代器 <code>it</code> 的后继，即 <code>++it</code>。</p>
</details>
<p>常见用法为用 <code>it = s.erase(it)</code> 替代 <code>s.erase(it++)</code>。</p>
<blockquote>
<p>实现一个函数，将 <code>set</code> 中属于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 的元素全部删除，并统计删除的个数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foobar</span><span class="params">(set&lt;<span class="type">int</span>&gt;&amp; s, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = s.<span class="built_in">lower_bound</span>(l);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (it != s.<span class="built_in">end</span>() &amp;&amp; *it &lt;= r)</span><br><span class="line">        it = s.<span class="built_in">erase</span>(it), res++;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<div class="note success"><p>多用 <code>insert(it, x), erase(it), it++, it--</code> 等高效函数。</p>
</div>
<h2 id="insertit-x-的用法"><a class="markdownIt-Anchor" href="#insertit-x-的用法"></a> <code>insert(it, x)</code> 的用法</h2>
<p>当我们想插入 x，并且知道插入的位置恰好在迭代器 pos 之前，就可以使用这个函数，复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，返回值为插入元素的迭代器。</p>
<p>如果 x 没有插入在迭代器 pos 之前，它就会重新调用 <code>insert(x)</code>，所以复杂度会退化到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
<blockquote>
<p>给定一个数组 <code>A[0..n-1]</code>，把它插入到 <code>set</code> 中。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="built_in">sort</span>(A, A + n);</span><br><span class="line"><span class="type">int</span> m = <span class="built_in">unique</span>(A, A + n) - A;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) s.<span class="built_in">insert</span>(s.<span class="built_in">end</span>(), A[i]);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同时插入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foobar</span><span class="params">(set&lt;<span class="type">int</span>&gt;&amp; s, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = s.<span class="built_in">insert</span>(x).first;</span><br><span class="line">    s.<span class="built_in">insert</span>(it, x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="eraseit-的妙用"><a class="markdownIt-Anchor" href="#eraseit-的妙用"></a> <code>erase(it)</code> 的妙用</h2>
<p><code>erase(it)</code> 函数复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。如果我们记录了每次插入产生的迭代器，就可以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 删除之前插入的元素。</p>
<blockquote>
<p>实现插入、删除和 <code>lower_bound</code> 操作，保证操作合法，元素值域为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator its[n];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    its[x] = s.<span class="built_in">insert</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    s.<span class="built_in">erase</span>(its[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lower_bound</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *s.<span class="built_in">lower_bound</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="it-it-的复杂度"><a class="markdownIt-Anchor" href="#it-it-的复杂度"></a> <code>it++, it--</code> 的复杂度</h2>
<p>理论上它们在随机数据下的复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的，但是大量测试的拟合复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，我猜测可能和缓存有关。尽管如此，它的速度仍然是 <code>find, lower_bound</code> 等函数的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 倍左右。</p>
<h2 id="一些便利的函数"><a class="markdownIt-Anchor" href="#一些便利的函数"></a> 一些便利的函数</h2>
<ul>
<li><code>prev(it)</code> 返回迭代器 <code>it</code> 的前驱，返回值等于 <code>--it</code>，但不会修改 <code>it</code>。<code>next(it)</code> 返回后继。</li>
<li><code>map&lt;int, int&gt;</code> 和 <code>set&lt;pair&lt;int, int&gt;&gt;</code> 可以使用 <code>emplace(x, y)</code> 来插入元素对。知道位置恰好在 it 之前的时候，使用 <code>emplace_hint(it, x, y)</code> 可以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 插入。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; s;</span><br><span class="line">m.<span class="built_in">emplace</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 等价于 m.insert(make_pair(1, 2))</span></span><br><span class="line"><span class="comment">// map::insert 不会覆盖已有的值，不同于 [] 赋值</span></span><br><span class="line">s.<span class="built_in">emplace</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 等价于 s.insert(make_pair(1, 2))</span></span><br><span class="line">m.<span class="built_in">emplace_hint</span>(m.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">s.<span class="built_in">emplace_hint</span>(m.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h1 id="初探循环展开"><a class="markdownIt-Anchor" href="#初探循环展开"></a> 初探循环展开</h1>
<p><em>11-06</em></p>
<p>本节在 O2 优化下讨论，因为 O3 会自动循环展开，编译器版本为 GCC 11.4。</p>
<h2 id="问题引入"><a class="markdownIt-Anchor" href="#问题引入"></a> 问题引入</h2>
<p>下面是一段简单数组求和代码，总共求了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span> 次和。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> a[<span class="number">5000</span>], sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">iota</span>(a, a + <span class="number">5000</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1&#x27;000&#x27;000</span>; k++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">        sum += a[i];</span><br><span class="line"><span class="built_in">assert</span>(sum); <span class="comment">// 防止编译器把这段代码删了</span></span><br></pre></td></tr></table></figure>
<p>在我电脑上的运行时间大概为 1.55s。</p>
<p>接下来进行一个简单地循环展开。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面省略</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        sum += a[i + <span class="number">0</span>];</span><br><span class="line">        sum += a[i + <span class="number">1</span>];</span><br><span class="line">        sum += a[i + <span class="number">2</span>];</span><br><span class="line">        sum += a[i + <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 后面省略</span></span><br></pre></td></tr></table></figure>
<p>运行时间大概为 1.16s，似乎并没有获得显著的加速。</p>
<p>换一个写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面省略</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i += <span class="number">4</span>)</span><br><span class="line">        sum += a[i] + a[i + <span class="number">1</span>] + a[i + <span class="number">2</span>] + a[i + <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 后面省略</span></span><br></pre></td></tr></table></figure>
<p>运行时间大概为 0.65s，直接比第一种循环展开快了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 倍。</p>
<h2 id="循环展开的原理"><a class="markdownIt-Anchor" href="#循环展开的原理"></a> 循环展开的原理</h2>
<p>从上面的例子可以看出，运行时间并不是完全由运算量决定的。</p>
<div class="note info"><h3 id="一个极端的例子"><a class="markdownIt-Anchor" href="#一个极端的例子"></a> 一个极端的例子</h3>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 矩阵乘法的运算量是固定的，但是 python 的矩阵乘法真的很快。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        python
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.random.rand(<span class="number">5000</span>, <span class="number">5000</span>)</span><br><span class="line">b = np.random.rand(<span class="number">5000</span>, <span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">c = np.matmul(a, b)</span><br><span class="line">end = time.time()</span><br><span class="line"><span class="built_in">print</span>(end - start)</span><br></pre></td></tr></table></figure>
    </div>
</div>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5000</mn><mo>×</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">5000\times 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 的 double 矩阵乘法用时 1.1s。</p>
</div>
<p>决定 CPU 实际效率的因素主要有三个：</p>
<ul>
<li>指令流水线 (instruction pipelining)。</li>
<li>缓存 (cache)。</li>
<li>SIMD (Single Instruction Multiple Data)</li>
</ul>
<p><em>指令流水线</em> 是实现 <em>指令级并行</em> 的技术，也是循环展开可以带来加速的重要原因。</p>
<p>执行任何一条机器指令，需要众多步骤，不过可以简单地分为 CPU 前端的流程和后端的流程。CPU 前端在内存中一次性读取多条机器代码，然后加入 <em>指令流水线</em> 的末尾，后端同时处理着 <em>指令流水线</em> 中的每个流程，尽可能使众多执行单元保持忙碌。</p>
<p>事实上流水线不可能完全通畅，流水线会因为三种原因阻塞：</p>
<ul>
<li>同一类型指令太多，相应的执行单元不够用。</li>
<li>当前指令需要得到上一条指令的结果才能开始执行。</li>
<li>分支预测失败。</li>
</ul>
<p>我们来解释一下这个求和代码在 CPU 中的执行细节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) sum += a[i];</span><br></pre></td></tr></table></figure>
<p>它编译后的汇编等效于这段 C++ 代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *rax = a, *rcx = a + n;</span><br><span class="line"><span class="type">unsigned</span> edx = <span class="number">0</span>;</span><br><span class="line">loop:</span><br><span class="line">    edx += *(<span class="type">unsigned</span>*)rax;</span><br><span class="line">    rax += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (rax != rcx)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br></pre></td></tr></table></figure>
<p>实际的汇编是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">    add edx, DWORD PTR [rax]</span><br><span class="line">    add rax, 4</span><br><span class="line">    cmp rax, rcx</span><br><span class="line">    jne loop</span><br></pre></td></tr></table></figure>
<p>另外，机器代码和汇编是一一对应的，所以机器代码也由这些语句构成。CPU 前端负责解析机器代码和完成循环的跳转 (jne)，CPU 后端则执行两条 add 和一条 cmp，由于 CPU 的执行单元足够多，所以三条指令会占用不同的执行单元。</p>
<p>第一次的循环展开变快很好解释，因为指令变少了，加速不显著是因为这些减少的指令原本就不和 <code>add edx, DWORD PTR [rax]</code> 共用执行单元。</p>
<p>第二次的循环展开变快的原因就很有意思了，指令数完全没有变少，但是加速很显著。第一次的循环展开只是把 <code>sum += a[i + ?]</code> 重复了四遍，它们构成了一条依赖链，因为 <code>sum += a[i + 1]</code> 必须要等上一条语句把 <code>sum</code> 算出来后才能执行，所以流水线会阻塞。而 <code>a[i] + a[i + 1] + a[i + 2] + a[i + 3]</code> 不存在这样严重的依赖链，对于每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>，<code>a[i] + a[i + 1] + a[i + 2] + a[i + 3]</code> 都可以并发地计算，虽然 <code>sum += </code> 的部分确实构成了依赖链，但是长度短得多。</p>
<p>最后给出一种推荐的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> s0 = <span class="number">0</span>, s1 = <span class="number">0</span>, s2 = <span class="number">0</span>, s3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    s0 += a[i + <span class="number">0</span>];</span><br><span class="line">    s1 += a[i + <span class="number">1</span>];</span><br><span class="line">    s2 += a[i + <span class="number">2</span>];</span><br><span class="line">    s3 += a[i + <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">sum += s0 + s1 + s2 + s3;</span><br></pre></td></tr></table></figure>
<p>运行时间大概为 0.62s，比第二次的循环展开有微小的进步。</p>
<h2 id="拓展"><a class="markdownIt-Anchor" href="#拓展"></a> 拓展</h2>
<p>除了求和之外，还有三个典型的例子：</p>
<h3 id="整体加"><a class="markdownIt-Anchor" href="#整体加"></a> 整体加</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> a[<span class="number">5000</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1&#x27;000&#x27;000</span>; k++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">        a[i]++;</span><br><span class="line"><span class="built_in">assert</span>(*<span class="built_in">max_element</span>(a, a + <span class="number">5000</span>));</span><br></pre></td></tr></table></figure>
<p>循环展开后有显著加速，因为 <code>a[i]++</code> 可以并发计算。</p>
<h3 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h3>
<p>下面两段代码速度差异很大。</p>
<div class="tabs" id="3"><ul class="nav-tabs"><li class="tab active"><a href="#3-1">第一种</a></li><li class="tab"><a href="#3-2">第二种</a></li></ul><div class="tab-content"><div class="tab-pane active" id="3-1"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> a[<span class="number">5000</span>];</span><br><span class="line">std::<span class="built_in">iota</span>(a, a + <span class="number">5000</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1&#x27;000&#x27;000</span>; k++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">        a[i] += a[i - <span class="number">1</span>];</span><br><span class="line"><span class="built_in">assert</span>(*<span class="built_in">max_element</span>(a, a + <span class="number">5000</span>));</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="3-2"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> a[<span class="number">5000</span>];</span><br><span class="line">std::<span class="built_in">iota</span>(a, a + <span class="number">5000</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1&#x27;000&#x27;000</span>; k++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; <span class="number">5000</span>; i++)</span><br><span class="line">        a[i + <span class="number">1</span>] += a[i];</span><br><span class="line"><span class="built_in">assert</span>(*<span class="built_in">max_element</span>(a, a + <span class="number">5000</span>));</span><br></pre></td></tr></table></figure></div></div></div>
<p>哪个快建议试一下，我觉得比较慢的那种是编译器锅了（GCC 12 修了），没优化到。</p>
<p>然后比较快的那种编译器会优化成这个样子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">    s += a[i], a[i] = s;</span><br></pre></td></tr></table></figure>
<p>循环展开后有较小加速。对于循环体很小的循环，展开后总是会有加速，因为指令数会减半。<code>s += a[i]</code> 构成了依赖链，没法并行，但 <code>a[i] = s</code> 能在一定程度上并行。</p>
<h3 id="小型矩阵乘法"><a class="markdownIt-Anchor" href="#小型矩阵乘法"></a> 小型矩阵乘法</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">unsigned</span> a[<span class="number">8</span>][<span class="number">8</span>], <span class="type">unsigned</span> b[<span class="number">8</span>][<span class="number">8</span>], <span class="type">unsigned</span> c[<span class="number">8</span>][<span class="number">8</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">            <span class="type">uint64_t</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)</span><br><span class="line">                sum += (<span class="type">uint64_t</span>)a[i][k] * b[k][j];</span><br><span class="line">            c[i][j] = sum % <span class="number">998244353</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把最内层循环打开后效果很好，这样乘法就可以并行。</p>
<h3 id="使用-pragma-自动展开"><a class="markdownIt-Anchor" href="#使用-pragma-自动展开"></a> 使用 pragma 自动展开</h3>
<p>全局自动展开就不说了，我觉得那个比较鸡肋。</p>
<p>推荐的做法是，在你想要展开的 <code>for</code> 前面加一句 <code>#pragma GCC unroll n</code>，其中 n 是一个数字，表示打开循环的步长。</p>
<p>以矩阵乘法为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">unsigned</span> a[<span class="number">8</span>][<span class="number">8</span>], <span class="type">unsigned</span> b[<span class="number">8</span>][<span class="number">8</span>], <span class="type">unsigned</span> c[<span class="number">8</span>][<span class="number">8</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">            <span class="type">uint64_t</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 完全展开</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> GCC unroll 8</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)</span><br><span class="line">                sum += (<span class="type">uint64_t</span>)a[i][k] * b[k][j];</span><br><span class="line">            c[i][j] = sum % <span class="number">998244353</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-c-template-自动展开"><a class="markdownIt-Anchor" href="#使用-c-template-自动展开"></a> 使用 C++ template 自动展开</h3>
<p>由于 OI 不能用 #pragma，所以再给一种方法，大概定义一个这样的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> M = (L + R) / <span class="number">2</span>&gt;</span><br><span class="line">__attribute__((always_inline)) <span class="keyword">inline</span> <span class="type">int</span> <span class="built_in">foobar</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (R - L == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">get_val</span>(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">foobar</span>&lt;L, M&gt;() + <span class="built_in">foobar</span>&lt;M, R&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__attribute__((always_inline)) inline</code> 表示强制内联，再配合 <code>template</code> 的递归就可以达到展开的效果。</p>
<p>还是以矩阵乘法为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> M = (L + R) / <span class="number">2</span>&gt;</span><br><span class="line">__attribute__((always_inline)) <span class="keyword">inline</span> <span class="type">uint64_t</span> <span class="built_in">foobar</span>(<span class="type">unsigned</span> a[<span class="number">8</span>][<span class="number">8</span>], <span class="type">unsigned</span> b[<span class="number">8</span>][<span class="number">8</span>], <span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (R - L == <span class="number">1</span>) <span class="built_in">return</span> (<span class="type">uint64_t</span>)a[i][L] * b[L][j];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">foobar</span>&lt;L, M&gt;(a, b, i, j) + <span class="built_in">foobar</span>&lt;M, R&gt;(a, b, i, j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">unsigned</span> a[<span class="number">8</span>][<span class="number">8</span>], <span class="type">unsigned</span> b[<span class="number">8</span>][<span class="number">8</span>], <span class="type">unsigned</span> c[<span class="number">8</span>][<span class="number">8</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">            c[i][j] = <span class="built_in">foobar</span>&lt;<span class="number">0</span>, <span class="number">8</span>&gt;(a, b, i, j) % <span class="number">998244353</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="循环的合并"><a class="markdownIt-Anchor" href="#循环的合并"></a> 循环的合并</h1>
<p><em>11-10</em></p>
<p>如果需要对数组 <code>a</code> 做两遍前缀和，最直接的写法是这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">    sum0 += a[i], a[i] = sum0;</span><br><span class="line"><span class="type">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">    sum1 += a[i], a[i] = sum1;</span><br></pre></td></tr></table></figure>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        完整测试代码
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> a[<span class="number">5000</span>];</span><br><span class="line">    <span class="built_in">iota</span>(a, a + <span class="number">5000</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1&#x27;000&#x27;000</span>; k++) &#123;</span><br><span class="line">        <span class="type">int</span> sum0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">            sum0 += a[i], a[i] = sum0;</span><br><span class="line">        <span class="type">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">            sum1 += a[i], a[i] = sum1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(*<span class="built_in">max_element</span>(a, a + <span class="number">5000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<p>运行时间大概 3.5s。</p>
<p>如果把两个循环合并起来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum0 = <span class="number">0</span>, sum1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">    sum0 += a[i], sum1 += sum0, a[i] = sum1;</span><br></pre></td></tr></table></figure>
<p>那么运行时间会减少到 2s。</p>
<p>合并循环最容易看到的好处是循环变量 <code>i</code> 的开销减半了，跳转的数量也减半了，不过这不是最主要的好处，真要减少循环开销还得用循环展开。以下两点才是合并循环的主要好处：</p>
<ul>
<li>内存读写减少了，当我们使用 <code>a[i]</code> 的值时，就需要读取内存，给 <code>a[i]</code> 赋值时，就需要写入内存，即使访问连续，内存读写也是有固定开销的。注意，这并不是说 <code>a[i] + a[i]</code> 会读取内存两次，O2 优化会智能地减少内存读写的次数。</li>
<li>缓解依赖关系。由于前缀和每次操作都依赖于上一次操作，所以指令级并行程度较低，合并循环后，仍然存在依赖关系，但是没那么严重了，更容易指令级并行。</li>
</ul>
<p>我们把循环合并前和合并后的代码都循环展开，对比一下速度：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">合并前</th>
<th style="text-align:center">合并后</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">不循环展开</td>
<td style="text-align:center">3.5s</td>
<td style="text-align:center">2s</td>
</tr>
<tr>
<td style="text-align:center">循环展开</td>
<td style="text-align:center">2.45s</td>
<td style="text-align:center">1.36s</td>
</tr>
</tbody>
</table>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        不合并循环 + 循环展开的代码
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> a[<span class="number">5000</span>];</span><br><span class="line">    <span class="built_in">iota</span>(a, a + <span class="number">5000</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1&#x27;000&#x27;000</span>; k++) &#123;</span><br><span class="line">        <span class="type">int</span> sum0 = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> GCC unroll 8</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">            sum0 += a[i], a[i] = sum0;</span><br><span class="line">        <span class="type">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> GCC unroll 8</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">            sum1 += a[i], a[i] = sum1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(*<span class="built_in">max_element</span>(a, a + <span class="number">5000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        合并循环 + 循环展开的代码
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> a[<span class="number">5000</span>];</span><br><span class="line">    <span class="built_in">iota</span>(a, a + <span class="number">5000</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1&#x27;000&#x27;000</span>; k++) &#123;</span><br><span class="line">        <span class="type">int</span> sum0 = <span class="number">0</span>, sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> GCC unroll 8</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">            sum0 += a[i], sum1 += sum0, a[i] = sum1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(*<span class="built_in">max_element</span>(a, a + <span class="number">5000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<p>当数组很大的时候，内存读写很慢，即使连续访问也会变慢，这时合并循环更重要了：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">合并前</th>
<th style="text-align:center">合并后</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5000</mn></mrow><annotation encoding="application/x-tex">5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 数组，迭代 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span> 次（循环展开）</td>
<td style="text-align:center">2.45s</td>
<td style="text-align:center">1.36s</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">5\times 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span> 数组，迭代 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000</mn></mrow><annotation encoding="application/x-tex">1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 次（循环展开）</td>
<td style="text-align:center">4.3s</td>
<td style="text-align:center">2.3s</td>
</tr>
</tbody>
</table>
<h2 id="合并循环在-oi-中的应用"><a class="markdownIt-Anchor" href="#合并循环在-oi-中的应用"></a> 合并循环在 OI 中的应用</h2>
<p>主要应用在 DP 和组合计数上，举两个例子：</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mn>3</mn><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><mn>2</mn><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">dp_{i,j}=3dp_{i-1,j}+2dp_{i-1,j-1}+dp_{i-1,j-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord">3</span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord">2</span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
</blockquote>
<p>不好的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) dp[i][j] = <span class="number">3LL</span> * dp[i - <span class="number">1</span>][j] % mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) dp[i][j] = (dp[i][j] + <span class="number">2LL</span> * dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j++) dp[i][j] = (dp[i][j] + <span class="number">1LL</span> * dp[i - <span class="number">1</span>][j - <span class="number">2</span>]) % mod;</span><br></pre></td></tr></table></figure>
<p>好的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j++) dp[i][j] = (<span class="number">3LL</span> * dp[i - <span class="number">1</span>][j] + <span class="number">2</span> * dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j - <span class="number">2</span>]) % mod;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">3LL</span> * dp[i - <span class="number">1</span>][<span class="number">0</span>] % mod;</span><br><span class="line">dp[i][<span class="number">1</span>] = (<span class="number">3LL</span> * dp[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">2</span> * dp[i - <span class="number">1</span>][<span class="number">0</span>]) % mod;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>高精度 A + B - C。</p>
</blockquote>
<p>自己实现吧。</p>
<h1 id="循环的分裂"><a class="markdownIt-Anchor" href="#循环的分裂"></a> 循环的分裂</h1>
<p><em>11-1?</em></p>
<h1 id="模算术优化-i"><a class="markdownIt-Anchor" href="#模算术优化-i"></a> 模算术优化 I</h1>
<p><em>11-1?</em></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      </div>
      
      
      
    </div>

    
    


    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder"></span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous">


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"platelett","repo":"platelett.github.io","client_id":"019ccf0c5fc00da2d39e","client_secret":"62107d94198d8589a43cee96c18197d4977bcafb","admin_user":"platelett","distraction_free_mode":true,"proxy":null,"language":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"6396342e254d96895f06f404c57035b1"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
