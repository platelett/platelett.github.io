---
title: (False)faces | Cerc2009
date: 2021-09-04 15:58:27
updated: 2021-09-04 15:58:27
tags: []
categories: Cerc
---
> [题目链接](https://darkbzoj.tk/problem/2586)
>
> 给定一个两边各有 $n$ 个点的二分图，判断完美匹配的个数是否是 $4$ 的倍数。
>
> $n \le 300$

完美匹配的个数即积和式。

来自论文的算法：求积和式模 $4$ 的余数。

积和式定义
$$
\text{perm }A = \sum_{p}A_{i,p_i}
$$
当 $A$ 是 $01$ 矩阵时，有
$$
\text{prem} A = (-1)^n\sum_{x_i \in \{0,1\}}(-1)^{x1+x2+\cdots+x_n}\prod_{i=1}^n(Ax)_i
$$
证明可以考虑容斥：强制一些列不能用。

观察到式子中间有一个 $\prod$ ，由于我们要求这个东西模 $4$ 的余数，因此 $(Ax)_i$ 至多只能有一个位置模 $2$ 为 $0$。

考虑 $(Ax)_i$ 每一项模 $2$ 的余数，由于至多只能有一个 $0$，因此可以枚举这个东西的取值，它只有 $n+1$ 种。

对于每种取值，通过高斯消元解出满足条件的所有 $x$，再将每一组 $x$ 代入刚刚的式子中求出答案。

问题是，合法的 $x$ 的个数可能很大，因为需要枚举自由元的取值。

对这个矩阵做一些变换。
$$
\begin{bmatrix}
A_{1,1}&A_{1,2}&\cdots &A_{1,n}&v_1\\
A_{2,1}&A_{2,2}&\cdots &A_{2,n}&v_2\\
\vdots&&&&\vdots\\
A_{n,1}&A_{n,2}&\cdots &A_{n,n}&v_n\\
0&0&\cdots&0&1
\end{bmatrix}
$$
这个矩阵的积和式等于原矩阵的积和式。

随机选取 $v$，则期望 $O(1)$ 组解。

直接写复杂度是 $O(n^4)$，预处理出 $A$ 的所有“逆元”（即所有的 $B$ 满足 $AB=I$），并使用 `bitset` 优化，复杂度为 $O(\frac {n^3}{\omega})$。

代码：

```cpp
#include <bits/stdc++.h>
#define rep(i, l, r) for(int i = (l); i <= (r); i++)
#define per(i, r, l) for(int i = (r); i >= (l); i--)
#define mem(a, b) memset(a, b, sizeof a)
#define For(i, l, r) for(int i = (l), i##e = (r); i < i##e; i++)
#define pb push_back
#pragma GCC target("popcnt")

using namespace std;

const int N = 305;

int T, n, idx;
char ans, s[N], x[N];
bitset<640> a[N], bas[N], fre[3], sol[5], X;

void dfs(int i) {
    if(i < 0) {
        sol[++idx].reset();
        rep(i, 0, n) sol[idx][i] = x[i];
    } else if(bas[i][i]) dfs(i - 1);
    else {
        x[i] = 0, dfs(i - 1);
        rep(k, 0, i) if(bas[k][i]) x[k] ^= 1;
        x[i] = 1, dfs(i - 1);
        rep(k, 0, i) if(bas[k][i]) x[k] ^= 1;
    }
}
int main() {
    cin.tie(0)->sync_with_stdio(0);
    for(cin >> T; T--;) {
        cin >> n;
        rep(i, 0, n) a[i].reset(), bas[i].reset();
        For(i, 0, n) {
            cin >> s, a[i][n] = rand() & 1, a[i][n + 1 + i] = a[i][n + n + 3] = 1;
            For(j, 0, n) a[i][j] = s[j] - 48;
        }
        a[n][n] = a[n][n + 1 + n] = a[n][n + n + 3] = 1;
        int p = 0;
        rep(i, 0, n) {
            auto nw = a[i];
            rep(j, 0, n) if(nw[j]) {
                if(bas[j][j]) nw ^= bas[j];
                else { bas[j] = nw; goto L; }
            }
            fre[++p] = nw; L:;
        }
        per(i, n, 0) if(bas[i][i]) rep(j, i + 1, n) if(bas[j][j] & bas[i][j]) bas[i] ^= bas[j];
        rep(i, 0, n) x[i] = bas[i][n + n + 3];
        idx = 0, X.reset(), ans = 0, dfs(n);
        bitset<640> y;
        rep(k, n + 1, n + n + 2) {
            rep(i, 0, n) y[i] = bas[i][k];
            bool ban = 0;
            rep(i, 1, p) ban |= fre[i][k] != fre[i][n + n + 3];
            if(ban) continue;
            rep(i, 1, idx) {
                X = sol[i] ^ y;
                char prod = 1;
                rep(j, 0, n) prod *= (a[j] & X).count();
                ans += X.count() & 1 ? -prod : prod;
            }
        }
        cout << (ans & 3 ? "NO\n" : "YES\n");
    }
}
```